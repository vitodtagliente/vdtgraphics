#include <chrono>
#include <iostream>
#include <memory>
#include <sstream>

#include <glad/glad.h>
#include <GLFW/glfw3.h>

#include <vdtgraphics/graphics.h>
#include <vdtmath/math.h>

using namespace std;
using namespace graphics;
using namespace math;

void init();
void render_loop();
void update();

float RandomFloat(float min, float max)
{
	float r = (float)rand() / (float)RAND_MAX;
	return min + r * (max - min);
}

double lastTick = 0;
double deltaTime = 0;
int drawCalls = 0;

math::vector2_t<int> screenSize(720, 480);

std::unique_ptr<Context> context;
std::unique_ptr<RenderTarget> renderTarget;
std::unique_ptr<Renderer> renderer;
std::unique_ptr<Renderer> renderer2;
math::vec3 mouse;
math::transform camera;


// last mouse wheel position
math::vec2 lastMouseWheelPosition;
// mouse wheel position
math::vec2 mouseWheelPosition;
// delta mouse wheel position
math::vec2 deltaMouseWheelPosition;
// zoom
float zoom_speed{ 1.0f };

void showFPS(GLFWwindow* pWindow)
{
	static int s_frames = 0;
	static double s_timer = 1.0;

	s_timer -= deltaTime;
	++s_frames;
	if (s_timer <= 0.0)
	{
		std::stringstream ss;
		ss << "vdtgraphics" << " " << "1.0" << " [" << s_frames << " FPS] DrawCalls[" << (renderer->stats.drawCalls + renderer2->stats.drawCalls) << "]";

		glfwSetWindowTitle(pWindow, ss.str().c_str());

		s_frames = 0;
		s_timer = 1.0;
	}
}

int main(void)
{
	GLFWwindow* window;

	/* Initialize the library */
	if (!glfwInit())
		return -1;

	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);

	/* Create a windowed mode window and its OpenGL context */
	window = glfwCreateWindow(screenSize.x, screenSize.y, "Hello World", NULL, NULL);
	if (!window)
	{
		glfwTerminate();
		return -1;
	}

	/* Make the window's context current */
	glfwMakeContextCurrent(window);

	context = std::make_unique<Context>();
	if (context->initialize() != Context::State::Initialized)
	{
		glfwTerminate();
		return -1;
	}

	renderer = std::make_unique<Renderer>();
	renderer->init(context.get());
	renderer2 = std::make_unique<Renderer>();
	renderer2->init(context.get());
	renderTarget = std::make_unique<RenderTarget>(screenSize.x, screenSize.y, Color(0.0f, 0.0f, 0.2f, 1.0f));

	init();

	glfwSetFramebufferSizeCallback(window,
		[](GLFWwindow*, const int width, const int height)
		{
			screenSize.x = width;
			screenSize.y = height;
			renderer->submitSetViewport(width, height);
			renderer2->submitSetViewport(width, height);
			renderTarget->resize(width, height);
		}
	);

	glfwSetCursorPosCallback(window,
		[](GLFWwindow* window, double xpos, double ypos)
		{
			mouse.x = (float)xpos;
			mouse.y = (float)ypos;
		}
	);

	// mouse wheel
	glfwSetScrollCallback(window,
		[](GLFWwindow*, const double x, const double y)
		{
			lastMouseWheelPosition = mouseWheelPosition;
			mouseWheelPosition = { static_cast<float>(x), static_cast<float>(y) };
			deltaMouseWheelPosition = mouseWheelPosition - lastMouseWheelPosition;
		}
	);

	// remove the fps cap
	glfwSwapInterval(0);

	/* Loop until the user closes the window */
	bool run = true;
	while (!glfwWindowShouldClose(window) && run)
	{
		// delta time
		{
			double currentTime = glfwGetTime();
			deltaTime = currentTime - lastTick;
			lastTick = currentTime;
		}

		// display the FPS
		showFPS(window);

		update();

		// render logic
		render_loop();

		/* Swap front and back buffers */
		glfwSwapBuffers(window);

		/* Poll for and process events */
		glfwPollEvents();
	}

	glfwTerminate();
	return 0;
}

Font font;
TexturePtr circleTexture;
TexturePtr potatoeTexture;
TexturePtr squareTexture;

void init()
{
	circleTexture = std::make_unique<Texture>(Image::load("../../../assets/circle.png"));
	potatoeTexture = std::make_unique<Texture>(Image::load("../../../assets/spritesheet.png"));
	squareTexture = std::make_unique<Texture>(Image::load("../../../assets/square.png"));
	font = Font::load("../../../assets/font.ttf");
}

std::chrono::steady_clock::time_point startTime;
void statsBegin()
{
	startTime = std::chrono::steady_clock::now();
}

void statsEnd(const std::string& context, const bool refresh = false)
{
	std::chrono::steady_clock::time_point endTime = std::chrono::steady_clock::now();
	std::cout << "Elapsed Time = " << std::chrono::duration_cast<std::chrono::microseconds>(endTime - startTime).count() << "[Âµs]" << " context[" << context << "]" << std::endl;

	if (refresh)
	{
		statsBegin();
	}
}

// Draw lines
void testCase1()
{
	renderer->submitDrawRect(ShapeRenderStyle::fill, math::vec3::zero, 10.f, 10.f, Color::Magenta);
	renderer->submitDrawRect(ShapeRenderStyle::stroke, math::vec3(-5.4f, 5.3f, 0.0f), 5.f, 5.f, Color::Green);
	renderer->submitDrawCircle(ShapeRenderStyle::stroke, math::vec3::zero, 15.f, Color::Yellow);
	renderer->submitDrawLine(math::vec3(-10.f, -10.f, 0.f), Color::Red, math::vec3(10.f, 10.f, 0.f), Color::Yellow);
	renderer->submitDrawTexture(potatoeTexture.get(), math::vec3::zero);
	renderer->submitDrawTexture(circleTexture.get(), math::vec3::zero, math::vec3(10.f, 10.f, 1.f), {}, Color::Cyan);
	renderer->submitDrawTexture(squareTexture.get(), math::vec3(5.f, 5.f, 0.f), math::vec3(5.f, 5.f, 1.f), {}, Color::Green);
}

// Draw different entities
void testCase2()
{
	struct Entity
	{
		math::transform transform;
		bool rotate;
		float rotateSpeed;
		TextureRect rect;
	};

	static std::vector<Entity> s_entities;

	// statsBegin();

	if (s_entities.empty())
	{
		for (int i = 0; i < 5000; ++i)
		{
			Entity entity;

			const float size = math::random(1.f, 1.f);

			entity.transform.position.x = math::random(-20.f, 20.f);
			entity.transform.position.y = math::random(-20.f, 20.f);
			entity.transform.position.z = 0.0f;

			entity.transform.rotation.z = math::random(0.f, 360.f);

			entity.transform.scale.x = entity.transform.scale.y = size;

			entity.transform.update();

			entity.rotate = math::random(0, 1) == 1;
			if (entity.rotate)
			{
				entity.rotateSpeed = math::random(10.f, 30.f);
			}

			const float s = 1.f / 11;
			entity.rect = TextureRect(s * 9, s * math::random(0, 5), s, s);

			s_entities.push_back(entity);
		}

		// statsEnd("generate data", true);
	}

	for (Entity& entity : s_entities)
	{
		if (entity.rotate)
		{
			entity.transform.rotation.z += entity.rotateSpeed * static_cast<float>(deltaTime);
			entity.transform.update();
		}
		renderer->submitDrawTexture(potatoeTexture.get(), entity.transform.matrix(), entity.rect);
	}

	// statsEnd("draw textures");
}

// Screen (input) coords to World coords
// draw a rectangle on mouse position
void testCase3()
{
	const float depth = 0.f;
	math::vec4 viewport = math::vec4(0, 0, static_cast<float>(screenSize.x), static_cast<float>(screenSize.y));
	math::vec3 screencoords = math::vec3(mouse.x, screenSize.y - mouse.y - 1, depth);
	math::vec3 objcoords = math::mat4::unproject(screencoords, renderer->getViewMatrix(), renderer->getProjectionMatrix(), viewport);
	objcoords.z = 0.5f;
	renderer->submitDrawTexture(circleTexture.get(), objcoords, math::vec3(.5f, .5f, 1.0f), {}, Color::Coral);
}

void update()
{
	if (deltaMouseWheelPosition.y != 0.f)
	{
		math::vec3& scale = camera.scale;
		scale.x = scale.y = scale.x + zoom_speed * static_cast<float>(deltaTime) * -deltaMouseWheelPosition.y;
	}
}

void render_loop()
{
	// scene graph layer like
	{
		renderer->setRenderTarget(renderTarget.get());
		const float aspectRatio = 1.0f;
		renderer->setProjectionMatrix(Camera::ortho(-10.f, 100.f, screenSize.x / 32, screenSize.y / 32, aspectRatio)); // 32 pixel per unit
		renderer->setViewMatrix(Camera::view(camera));
		renderer->submitSetViewport(screenSize.x, screenSize.y);
		testCase1();
		testCase2();
		testCase3();

		renderer->setRenderTarget(nullptr);
		renderer->setProjectionMatrix(math::mat4::scale({ 2.f, -2.f, 1.f }));
		renderer->setViewMatrix(math::mat4::identity);
		renderer->submitSetViewport(screenSize.x, screenSize.y);
		renderer->submitDrawTexture(renderTarget->getTexture(), math::vec3::zero);
		renderer->draw();
	}

	// ui layer like
	{
		renderer2->setProjectionMatrix(math::mat4::identity);
		renderer2->setViewMatrix(math::mat4::identity);
		renderer2->submitSetViewport(screenSize.x, screenSize.y);
		renderer2->submitDrawRect(ShapeRenderStyle::fill, math::vec3::zero, 1.2f, .3f, Color::Aquamarine);
		renderer2->submitDrawText(&font, "vdtgraphics", math::vec3(-.3f, 0.f, 1.f), .1f, Color::White);
		renderer2->draw();
	}
}